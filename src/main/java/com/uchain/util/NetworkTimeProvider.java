package com.uchain.util;import com.google.common.util.concurrent.*;import com.uchain.main.NetworkTimeProviderSettings;import org.apache.commons.net.ntp.NTPUDPClient;import org.apache.commons.net.ntp.TimeInfo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.net.InetAddress;import java.net.SocketException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.atomic.AtomicLong;public class NetworkTimeProvider {    private NetworkTimeProviderSettings ntpSettings;    private static Logger log = LoggerFactory.getLogger(NetworkTimeProvider.class);    private AtomicLong lastUpdate = new AtomicLong(0);    private AtomicLong offset = new AtomicLong(0);    private NTPUDPClient client = new NTPUDPClient();    public NetworkTimeProvider(NetworkTimeProviderSettings ntpSettings) {        this.ntpSettings = ntpSettings;        client.setDefaultTimeout(Math.toIntExact(ntpSettings.getTimeout().toMillis()));        try {            client.open();        } catch (SocketException e) {            e.printStackTrace();        }    }    private void checkUpdateRequired() {            long time = System.currentTimeMillis() + offset.get();            long lu = lastUpdate.getAndSet(time);            if (time > lu + ntpSettings.getUpdateEvery().toMillis()) {                ExecutorService executor = Executors.newFixedThreadPool(1);                // 使用guava提供的MoreExecutors工具类包装原始的线程池                ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(executor);                //向线程池中提交一个任务后，将会返回一个可监听的Future，该Future由Guava框架提供                ListenableFuture<Long> lf = listeningExecutor.submit(() -> {                    TimeInfo info = null;                    try {                        info = client.getTime(InetAddress.getByName(ntpSettings.getServer()));                    } catch (IOException e) {                        e.printStackTrace();                    }                    info.computeDetails();                    return info.getOffset();                });                //添加回调，回调由executor中的线程触发，但也可以指定一个新的线程                Futures.addCallback(lf, new FutureCallback<Long>() {                    //耗时任务执行成功后回调该方法                    @Override                    public void onSuccess(Long newOffset) {                        offset.set(newOffset);                        log.info("新时间偏移调整: " + offset);                        lastUpdate.set(time);                    }                    //耗时任务执行失败后回调该方法                    @Override                    public void onFailure(Throwable e) {                        log.warn("Problems with NTP: ", e);                        lastUpdate.compareAndSet(time, lu);                    }                });                listeningExecutor.shutdown();            } else {                lastUpdate.compareAndSet(time, lu);            }    }    public long time(){        //checkUpdateRequired();    // NTP disabled        return System.currentTimeMillis() + offset.get();    }}