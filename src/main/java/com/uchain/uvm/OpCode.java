package com.uchain.uvm;import java.util.Arrays;import java.util.EnumSet;import java.util.HashMap;import java.util.Map;import static com.uchain.uvm.OpCode.Tier.*;/** * 虚拟机指令集 */public enum OpCode {    /* 算术运算 */    /**     * (0x00) 暂停执行     */    STOP(0x00, 0, 0, ZeroTier),    /**     * (0x01) 加法运算     */    ADD(0x01, 2, 1, VeryLowTier),    /**     * (0x02) 乘积运算     */    MUL(0x02, 2, 1, LowTier),    /**     * (0x03) 减法运算     */    SUB(0x03, 2, 1, VeryLowTier),    /**     * (0x04) 整数除法运算     */    DIV(0x04, 2, 1, LowTier),    /**     * (0x05) 有符号整数除法运算     */    SDIV(0x05, 2, 1, LowTier),    /**     * (0x06) 求模操作运算     */    MOD(0x06, 2, 1, LowTier),    /**     * (0x07) 有符号求模操作运算     */    SMOD(0x07, 2, 1, LowTier),    /**     * (0x08) 先加再求模运算     */    ADDMOD(0x08, 3, 1, MidTier),    /**     * (0x09) 先乘再求模运算     */    MULMOD(0x09, 3, 1, MidTier),    /**     * (0x0a) 指数运算     */    EXP(0x0a, 2, 1, SpecialTier),    /**     * (0x0b) 扩展有符号整数的长度     */    SIGNEXTEND(0x0b, 2, 1, LowTier),    /*  按位逻辑和比较操作   */    /**     * (0x10) 小于比较     */    LT(0X10, 2, 1, VeryLowTier),    /**     * (0x11) 大于比较     */    GT(0X11, 2, 1, VeryLowTier),    /**     * (0x12) 有符号小于比较     */    SLT(0X12, 2, 1, VeryLowTier),    /**     * (0x13) 有符号大于比较     */    SGT(0X13, 2, 1, VeryLowTier),    /**     * (0x14) 等于比较     */    EQ(0X14, 2, 1, VeryLowTier),    /**     * (0x15) 否定运算     */    ISZERO(0x15, 1, 1, VeryLowTier),    /**     * (0x16) 按位与运算     */    AND(0x16, 2, 1, VeryLowTier),    /**     * (0x17) 按位或运算     */    OR(0x17, 2, 1, VeryLowTier),    /**     * (0x18) 按位异或运算     */    XOR(0x18, 2, 1, VeryLowTier),    /**     * (0x19) 按位非运算     */    NOT(0x19, 1, 1, VeryLowTier),    /**     * (0x1a) 从字检索单个字节     */    BYTE(0x1a, 2, 1, VeryLowTier),    /**     * (0x1b) 左移     */    SHL(0x1b, 2, 1, VeryLowTier),    /**     * (0x1c) 右移     */    SHR(0x1c, 2, 1, VeryLowTier),    /**     * (0x1d) 算术右移     */    SAR(0x1d, 2, 1, VeryLowTier),    /*  密码操作    */    /**     * (0x20) 计算SHA3-256散列     */    SHA3(0x20, 2, 1, SpecialTier),    /*  环境信息   */    /**     * (0x30)  获取当前执行帐户的地址     */    ADDRESS(0x30, 0, 1, BaseTier),    /**     * (0x31) 获取给定帐户的余额     */    BALANCE(0x31, 1, 1, ExtTier),    /**     * (0x32) 获取执行起始地址     */    ORIGIN(0x32, 0, 1, BaseTier),    /**     * (0x33) 获取调用者地址     */    CALLER(0x33, 0, 1, BaseTier),    /**     * (0x34) 通过负责此执行的指令/事务获取存储值     */    CALLVALUE(0x34, 0, 1, BaseTier),    /**     * (0x35) 获取当前环境的输入数据     */    CALLDATALOAD(0x35, 1, 1, VeryLowTier),    /**     * (0x36) 获取当前环境中的输入数据的大小     */    CALLDATASIZE(0x36, 0, 1, BaseTier),    /**     * (0x37) 将当前环境中的输入数据复制到内存     */    CALLDATACOPY(0x37, 3, 0, VeryLowTier),    /**     * (0x38) 获取在当前环境中运行的代码的大小     */    CODESIZE(0x38, 0, 1, BaseTier),    /**     * (0x39) 将当前环境中运行的代码复制到内存     */    CODECOPY(0x39, 3, 0, VeryLowTier), // [len code_start mem_start CODECOPY]    RETURNDATASIZE(0x3d, 0, 1, BaseTier),    RETURNDATACOPY(0x3e, 3, 0, VeryLowTier),    /**     * (0x3a) 获取当前环境中的气体价格     */    GASPRICE(0x3a, 0, 1, BaseTier),    /**     * (0x3b) 获取在当前环境中使用给定偏移量运行的代码大小     */    EXTCODESIZE(0x3b, 1, 1, ExtTier),    /**     * (0x3c) 将在当前环境中运行的代码复制到具有给定偏移量的内存中     */    EXTCODECOPY(0x3c, 4, 0, ExtTier),    /**     * (0x3f) 返回合约代码的KECAK256哈希值     */    EXTCODEHASH(0x3f, 1,1 , ExtTier),    /*  块信息   */    /**     * (0x40) 获取最近完成块的哈希值     */    BLOCKHASH(0x40, 1, 1, ExtTier),    /**     * (0x41) 获取块的硬币基地址     */    COINBASE(0x41, 0, 1, BaseTier),    /**     * (x042) 获取块的时间戳     */    TIMESTAMP(0x42, 0, 1, BaseTier),    /**     * (0x43) 获取块的编号     */    NUMBER(0x43, 0, 1, BaseTier),    /**     * (0x44) 获得块的难度     */    DIFFICULTY(0x44, 0, 1, BaseTier),    /**     * (0x45) 获取块的气体限制     */    GASLIMIT(0x45, 0, 1, BaseTier),    /*  内存，存储和流操作 */    /**     * (0x50) 出栈     */    POP(0x50, 1, 0, BaseTier),    /**     * (0x51) 从内存加载字     */    MLOAD(0x51, 1, 1, VeryLowTier),    /**     * (0x52) 将word保存到内存     */    MSTORE(0x52, 2, 0, VeryLowTier),    /**     * (0x53) 将byte保存到存储器     */    MSTORE8(0x53, 2, 0, VeryLowTier),    /**     * (0x54) 从存储器加载word     */    SLOAD(0x54, 1, 1, SpecialTier),    /**     * (0x55) 将word保存到存储     */    SSTORE(0x55, 2, 0, SpecialTier),    /**     * (0x56) 跳转     */    JUMP(0x56, 1, 0, MidTier),    /**     * (0x57) 有条件跳转     */    JUMPI(0x57, 2, 0, HighTier),    /**     * (0x58) 获取程序计数器     */    PC(0x58, 0, 1, BaseTier),    /**     * (0x59) 获取活动内存的大小     */    MSIZE(0x59, 0, 1, BaseTier),    /**     * (0x5a) 获取可用气体的量     */    GAS(0x5a, 0, 1, BaseTier),    /**     * (0x5b) 无操作     */    JUMPDEST(0x5b, 0, 0, SpecialTier),    /*   Push操作 */    /**     * (0x60) 将1字节项放在堆栈上     */    PUSH1(0x60, 0, 1, VeryLowTier),    /**     * (0x61) 将2字节项放在堆栈上     */    PUSH2(0x61, 0, 1, VeryLowTier),    /**     * (0x62) 将3字节项放在堆栈上     */    PUSH3(0x62, 0, 1, VeryLowTier),    /**     * (0x63) 将4字节项放在堆栈上     */    PUSH4(0x63, 0, 1, VeryLowTier),    /**     * (0x64) 将5字节项放在堆栈上     */    PUSH5(0x64, 0, 1, VeryLowTier),    /**     * (0x65) 将6字节项放在堆栈上     */    PUSH6(0x65, 0, 1, VeryLowTier),    /**     * (0x66) 将7字节项放在堆栈上     */    PUSH7(0x66, 0, 1, VeryLowTier),    /**     * (0x67) 将8字节项放在堆栈上     */    PUSH8(0x67, 0, 1, VeryLowTier),    /**     * (0x68) 将9字节项放在堆栈上     */    PUSH9(0x68, 0, 1, VeryLowTier),    /**     * (0x69) 将10字节项放在堆栈上     */    PUSH10(0x69, 0, 1, VeryLowTier),    /**     * (0x6a) 将11字节项放在堆栈上     */    PUSH11(0x6a, 0, 1, VeryLowTier),    /**     * (0x6b) 将12字节项放在堆栈上     */    PUSH12(0x6b, 0, 1, VeryLowTier),    /**     * (0x6c) 将13字节项放在堆栈上     */    PUSH13(0x6c, 0, 1, VeryLowTier),    /**     * (0x6d) 将14字节项放在堆栈上     */    PUSH14(0x6d, 0, 1, VeryLowTier),    /**     * (0x6e) 将15字节项放在堆栈上     */    PUSH15(0x6e, 0, 1, VeryLowTier),    /**     * (0x6f) 将16字节项放在堆栈上     */    PUSH16(0x6f, 0, 1, VeryLowTier),    /**     * (0x70) 将17字节项放在堆栈上     */    PUSH17(0x70, 0, 1, VeryLowTier),    /**     * (0x71) 将18字节项放在堆栈上     */    PUSH18(0x71, 0, 1, VeryLowTier),    /**     * (0x72) 将19字节项放在堆栈上     */    PUSH19(0x72, 0, 1, VeryLowTier),    /**     * (0x73) 将字20节项放在堆栈上     */    PUSH20(0x73, 0, 1, VeryLowTier),    /**     * (0x74) 将21字节项放在堆栈上     */    PUSH21(0x74, 0, 1, VeryLowTier),    /**     * (0x75) 将22字节项放在堆栈上     */    PUSH22(0x75, 0, 1, VeryLowTier),    /**     * (0x76) 将23字节项放在堆栈上     */    PUSH23(0x76, 0, 1, VeryLowTier),    /**     * (0x77) 将24字节项放在堆栈上     */    PUSH24(0x77, 0, 1, VeryLowTier),    /**     * (0x78) 将25字节项放在堆栈上     */    PUSH25(0x78, 0, 1, VeryLowTier),    /**     * (0x79) 将26字节项放在堆栈上     */    PUSH26(0x79, 0, 1, VeryLowTier),    /**     * (0x7a) 将27字节项放在堆栈上     */    PUSH27(0x7a, 0, 1, VeryLowTier),    /**     * (0x7b) 将28字节项放在堆栈上     */    PUSH28(0x7b, 0, 1, VeryLowTier),    /**     * (0x7c) 将29字节项放在堆栈上     */    PUSH29(0x7c, 0, 1, VeryLowTier),    /**     * (0x7d) 将30字节项放在堆栈上     */    PUSH30(0x7d, 0, 1, VeryLowTier),    /**     * (0x7e) 将31字节项放在堆栈上     */    PUSH31(0x7e, 0, 1, VeryLowTier),    /**     * (0x7f) 将32字节项放在堆栈上     */    PUSH32(0x7f, 0, 1, VeryLowTier),    /*   从堆栈复制第N个项目   */    /**     * (0x80) 在堆栈上复制第1条数据     */    DUP1(0x80, 1, 2, VeryLowTier),    /**     * (0x81) 在堆栈上复制第2条数据     */    DUP2(0x81, 2, 3, VeryLowTier),    /**     * (0x82) 在堆栈上复制第3条数据     */    DUP3(0x82, 3, 4, VeryLowTier),    /**     * (0x83) 在堆栈上复制第4条数据     */    DUP4(0x83, 4, 5, VeryLowTier),    /**     * (0x84) 在堆栈上复制第5条数据     */    DUP5(0x84, 5, 6, VeryLowTier),    /**     * (0x85) 在堆栈上复制第6条数据     */    DUP6(0x85, 6, 7, VeryLowTier),    /**     * (0x86) 在堆栈上复制第7条数据     */    DUP7(0x86, 7, 8, VeryLowTier),    /**     * (0x87) 在堆栈上复制第8条数据     */    DUP8(0x87, 8, 9, VeryLowTier),    /**     * (0x88) 在堆栈上复制第9条数据     */    DUP9(0x88, 9, 10, VeryLowTier),    /**     * (0x89) 在堆栈上复制第10条数据     */    DUP10(0x89, 10, 11, VeryLowTier),    /**     * (0x8a) 在堆栈上复制第11条数据     */    DUP11(0x8a, 11, 12, VeryLowTier),    /**     * (0x8b) 在堆栈上复制第条12数据     */    DUP12(0x8b, 12, 13, VeryLowTier),    /**     * (0x8c) 在堆栈上复制第13条数据     */    DUP13(0x8c, 13, 14, VeryLowTier),    /**     * (0x8d) 在堆栈上复制第14条数据     */    DUP14(0x8d, 14, 15, VeryLowTier),    /**     * (0x8e) 在堆栈上复制第条15数据     */    DUP15(0x8e, 15, 16, VeryLowTier),    /**     * (0x8f) 在堆栈上复制第16条数据     */    DUP16(0x8f, 16, 17, VeryLowTier),    /*  使用顶部数据交换堆栈中的第N项数据   */    /**     * (0x90) 堆栈的顶部数据和第2项数据交换     */    SWAP1(0x90, 2, 2, VeryLowTier),    /**     * (0x91) 堆栈的顶部数据和第3项数据交换     */    SWAP2(0x91, 3, 3, VeryLowTier),    /**     * (0x92) 堆栈的顶部数据和第4项数据交换     */    SWAP3(0x92, 4, 4, VeryLowTier),    /**     * (0x93) 堆栈的顶部数据和第5项数据交换     */    SWAP4(0x93, 5, 5, VeryLowTier),    /**     * (0x94) 堆栈的顶部数据和第6项数据交换     */    SWAP5(0x94, 6, 6, VeryLowTier),    /**     * (0x95) 堆栈的顶部数据和第7项数据交换     */    SWAP6(0x95, 7, 7, VeryLowTier),    /**     * (0x96) 堆栈的顶部数据和第8项数据交换     */    SWAP7(0x96, 8, 8, VeryLowTier),    /**     * (0x97) 堆栈的顶部数据和第9项数据交换     */    SWAP8(0x97, 9, 9, VeryLowTier),    /**     * (0x98) 堆栈的顶部数据和第10项数据交换     */    SWAP9(0x98, 10, 10, VeryLowTier),    /**     * (0x99) 堆栈的顶部数据和第11项数据交换     */    SWAP10(0x99, 11, 11,VeryLowTier),    /**     * (0x9a) 堆栈的顶部数据和第12项数据交换     */    SWAP11(0x9a, 12, 12, VeryLowTier),    /**     * (0x9b) 堆栈的顶部数据和第13项数据交换     */    SWAP12(0x9b, 13, 13, VeryLowTier),    /**     * (0x9c) 堆栈的顶部数据和第14项数据交换     */    SWAP13(0x9c, 14, 14, VeryLowTier),    /**     * (0x9d) 堆栈的顶部数据和第15项数据交换     */    SWAP14(0x9d, 15, 15, VeryLowTier),    /**     * (0x9e) 堆栈的顶部数据和第16项数据交换     */    SWAP15(0x9e, 16, 16, VeryLowTier),    /**     * (0x9f) 堆栈的顶部数据和第17项数据交换     */    SWAP16(0x9f, 17, 17, VeryLowTier),    /**     * (0xa[n]) 使用0..n标记记录一些地址的一些数据     */    LOG0(0xa0, 2, 0, SpecialTier),    LOG1(0xa1, 3, 0, SpecialTier),    LOG2(0xa2, 4, 0, SpecialTier),    LOG3(0xa3, 5, 0, SpecialTier),    LOG4(0xa4, 6, 0, SpecialTier),    /*  系统操作   */    /**     * (0xf0) 创建具有关联代码的新帐户     */    CREATE(0xf0, 3, 1, SpecialTier),   //       [in_size] [in_offs] [gas_val] CREATE    /**     * (cxf1) 消息呼叫到帐户     */    CALL(0xf1, 7, 1, SpecialTier, CallFlags.Call, CallFlags.HasValue),    //       [out_data_size] [out_data_start] [in_data_size] [in_data_start] [value] [to_addr]    // [gas] CALL    /**     * (0xf2) 调用自己，但是从TO参数而不是从自己的地址获取代码     */    CALLCODE(0xf2, 7, 1, SpecialTier, CallFlags.Call, CallFlags.HasValue, CallFlags.Stateless),    /**     * (0xf3) 暂停执行返回输出数据     */    RETURN(0xf3, 2, 0, ZeroTier),    /**     * (0xf4)  在理念上类似于CALLCODE，除了它将发送者和值从父作用域传播到子作用域     */    DELEGATECALL(0xf4, 6, 1, SpecialTier, CallFlags.Call, CallFlags.Stateless, CallFlags.Delegate),    /**     * (0xf5) 与创建相同，但具有确定性地址     */    CREATE2(0xf5, 4, 1, SpecialTier),    STATICCALL(0xfa, 6, 1, SpecialTier, CallFlags.Call, CallFlags.Static),    /**     * (0xfd) “REVERT”指令将停止执行，回滚到目前为止所做的所有状态更改     *     * 以及提供指向存储器部分的指针，其可以被解释为错误代码或消息。     *     * 这样做时，它不会消耗所有剩余的气体。.     */    REVERT(0xfd, 2, 0, ZeroTier),    /**     * (0xff) 暂停执行并注册帐户以便稍后删除     */    SUICIDE(0xff, 1, 0, ZeroTier);    private final byte opcode;    private final int require;    private final Tier tier;    private final int ret;    private final EnumSet<CallFlags> callFlags;    private static final OpCode[] intToTypeMap = new OpCode[256];    private static final Map<String, Byte> stringToByteMap = new HashMap<>();    static {        for (OpCode type : OpCode.values()) {            intToTypeMap[type.opcode & 0xFF] = type;            stringToByteMap.put(type.name(), type.opcode);        }    }    private OpCode(int op, int require, int ret, Tier tier, CallFlags ... callFlags) {        this.opcode = (byte) op;        this.require = require;        this.tier = tier;        this.ret = ret;        this.callFlags = callFlags.length == 0 ? EnumSet.noneOf(CallFlags.class) :                EnumSet.copyOf(Arrays.asList(callFlags));    }    public byte val() {        return opcode;    }    public int require() {        return require;    }    public int ret() {        return ret;    }    public int asInt() {        return opcode;    }    public static boolean contains(String code) {        return stringToByteMap.containsKey(code.trim());    }    public static byte byteVal(String code) {        return stringToByteMap.get(code);    }    public static OpCode code(byte code) {        return intToTypeMap[code & 0xFF];    }    private EnumSet<CallFlags> getCallFlags() {        return callFlags;    }    /**     * 指示操作码是一个调用     */    public boolean isCall() {        return getCallFlags().contains(CallFlags.Call);    }    private void checkCall() {        if (!isCall()) throw new RuntimeException("Opcode is not a call: " + this);    }    /**     *  指示代码是在调用方上下文中执行的     */    public boolean callIsStateless() {        checkCall();        return getCallFlags().contains(CallFlags.Stateless);    }    /**     *  指示操作码具有值参数（堆栈上的第三）     */    public boolean callHasValue() {        checkCall();        return getCallFlags().contains(CallFlags.HasValue);    }    /**     *  指示在调用期间不允许任何状态修改     */    public boolean callIsStatic() {        checkCall();        return getCallFlags().contains(CallFlags.Static);    }    /**     *  指示值和消息发送方从父范围传播到子范围     */    public boolean callIsDelegate() {        checkCall();        return getCallFlags().contains(CallFlags.Delegate);    }    public Tier getTier() {        return this.tier;    }    public enum Tier {        ZeroTier(0),        BaseTier(2),        VeryLowTier(3),        LowTier(5),        MidTier(8),        HighTier(10),        ExtTier(20),        SpecialTier(1), //TODO #POC9 is this correct?? "multiparam" from cpp        InvalidTier(0);        private final int level;        private Tier(int level) {            this.level = level;        }        public int asInt() {            return level;        }    }    private enum CallFlags {        /**         * 指示操作码是一个调用         */        Call,        /**         *  指示代码是在调用方上下文中执行的         */        Stateless,        /**         *  指示操作码具有值参数（堆栈上的第三）         */        HasValue,        /**         *  指示在调用期间不允许任何状态修改         */        Static,        /**         *  指示值和消息发送方从父范围传播到子范围         */        Delegate    }}